<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bee Image Ruler Tool</title>
    <style>
        body { font-family: Arial; padding: 20px; max-width: 900px; margin: 0 auto; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; }
        .subtitle { color: #666; margin-bottom: 20px; }
        .section { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #eee; }
        .section:last-child { border-bottom: none; }
        .section h2 { font-size: 18px; margin-top: 0; }
        canvas { border: 2px solid #ccc; max-width: 100%; display: block; margin: 20px 0; background: #f9f9f9; cursor: crosshair; }
        input[type="file"], input[type="number"], button, select { padding: 10px 15px; margin: 5px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; font-family: Arial; }
        button { background: #2196F3; color: white; border: none; cursor: pointer; font-weight: bold; }
        button:hover { background: #1976D2; }
        button.active { background: #1976D2; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-end; }
        .info-box { background: #e3f2fd; border-left: 4px solid #2196F3; padding: 12px 15px; margin: 15px 0; border-radius: 4px; font-size: 14px; }
        .message { padding: 10px; margin: 5px 0; border-radius: 4px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .status { padding: 10px 15px; border-radius: 4px; margin: 10px 0; font-weight: bold; }
        .status.uncalibrated { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status.calibrated { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .results { display: flex; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .result-box { background: #f9f9f9; padding: 15px; border: 1px solid #ddd; border-radius: 4px; min-width: 150px; }
        .result-label { font-size: 12px; color: #666; text-transform: uppercase; }
        .result-value { font-size: 28px; font-weight: bold; color: #2196F3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêù Bee Image Ruler Tool</h1>
        <p class="subtitle">Measure bee images with calibration using any reference object of known size</p>

        <div class="section">
            <h2>Step 1: Upload Image</h2>
            <label>Select Image File:</label><br>
            <input type="file" id="imageFile" accept="image/*">
            <div class="info-box">
                üí° Upload a photo of your bee specimen or reference object. Works with JPG, PNG, and other image formats.
            </div>
        </div>

        <div class="section">
            <h2>Step 2: Calibrate Using Reference Object</h2>
            <div id="calibrationStatus" class="status uncalibrated">
                ‚ö†Ô∏è Not calibrated yet
            </div>
            <div class="info-box">
                Click on two points in your image that mark the edges of a reference object (ruler, coin, bank card, petri dish, etc.), then enter the actual size below.
            </div>
            
            <div class="controls">
                <button id="calibrateBtn" class="active">üìè Calibrate Mode</button>
                <button id="measureBtn">üìê Measure Mode</button>
            </div>

            <div id="calibrationPoints" class="info-box" style="display: none;">
                Points selected: <span id="calibrationPointsCount">0/2</span>
            </div>

            <div class="controls" id="calibrationInputs" style="display: none;">
                <label>Reference Object Size:</label>
                <input type="number" id="referenceSize" placeholder="Enter size" step="0.01" min="0">
                <select id="referenceUnit">
                    <option value="mm">mm</option>
                    <option value="cm">cm</option>
                    <option value="inches">inches</option>
                </select>
                <button id="applyCalibrationBtn">Apply Calibration</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>

        <div class="section">
            <h2>Step 3: Measure Bee</h2>
            <div class="info-box">
                Switch to Measure Mode, then click on two points in your image to measure the distance between them.
            </div>

            <div id="measurementPoints" class="info-box" style="display: none;">
                Points selected: <span id="measurementPointsCount">0/2</span>
            </div>

            <div id="results" class="results" style="display: none;">
                <div class="result-box">
                    <div class="result-label">Measurement (mm)</div>
                    <div class="result-value" id="resultMM">0.00</div>
                </div>
                <div class="result-box">
                    <div class="result-label">Measurement (inches)</div>
                    <div class="result-value" id="resultInches">0.000</div>
                </div>
            </div>
        </div>

        <div id="messages"></div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageFile = document.getElementById('imageFile');
        const messagesDiv = document.getElementById('messages');
        const calibrationStatus = document.getElementById('calibrationStatus');
        const calibrationPoints = document.getElementById('calibrationPoints');
        const measurementPoints = document.getElementById('measurementPoints');
        const calibrationInputs = document.getElementById('calibrationInputs');
        const results = document.getElementById('results');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const measureBtn = document.getElementById('measureBtn');
        const applyCalibrationBtn = document.getElementById('applyCalibrationBtn');
        const resetBtn = document.getElementById('resetBtn');
        const referenceSize = document.getElementById('referenceSize');
        const referenceUnit = document.getElementById('referenceUnit');

        let img = null;
        let currentMode = 'calibrate';
        let calibrationPts = [];
        let measurementPts = [];
        let pixelsPerMM = null;

        function addMessage(text, type = 'info') {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            messagesDiv.appendChild(msg);
            setTimeout(() => msg.remove(), 5000);
        }

        // Image upload
        imageFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                img = new Image();
                img.onload = () => {
                    drawImage();
                    calibrationPoints.style.display = 'block';
                    measurementPoints.style.display = 'block';
                    calibrationInputs.style.display = 'flex';
                    addMessage(`Image loaded: ${img.width}x${img.height}px`, 'success');
                };
                img.onerror = () => {
                    addMessage('Error loading image', 'error');
                };
                img.src = event.target.result;
            };
            reader.onerror = () => {
                addMessage('Error reading file', 'error');
            };
            reader.readAsDataURL(file);
        });

        // Mode buttons
        calibrateBtn.addEventListener('click', () => {
            currentMode = 'calibrate';
            calibrateBtn.classList.add('active');
            measureBtn.classList.remove('active');
            measurementPts = [];
            results.style.display = 'none';
            updateDisplay();
        });

        measureBtn.addEventListener('click', () => {
            if (!pixelsPerMM) {
                addMessage('Please calibrate first', 'error');
                return;
            }
            currentMode = 'measure';
            measureBtn.classList.add('active');
            calibrateBtn.classList.remove('active');
            measurementPts = [];
            results.style.display = 'none';
            updateDisplay();
        });

        // Canvas click
        canvas.addEventListener('click', (e) => {
            if (!img) {
                addMessage('Please upload an image first', 'error');
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const scaleX = img.width / canvas.width;
            const scaleY = img.height / canvas.height;
            const imgX = clickX * scaleX;
            const imgY = clickY * scaleY;

            if (currentMode === 'calibrate') {
                if (calibrationPts.length < 2) {
                    calibrationPts.push({ x: imgX, y: imgY, canvasX: clickX, canvasY: clickY });
                    updateDisplay();
                    drawImage();
                }
            } else if (currentMode === 'measure') {
                if (measurementPts.length < 2) {
                    measurementPts.push({ x: imgX, y: imgY, canvasX: clickX, canvasY: clickY });
                    updateDisplay();
                    drawImage();
                    if (measurementPts.length === 2) {
                        calculateMeasurement();
                    }
                }
            }
        });

        // Apply calibration
        applyCalibrationBtn.addEventListener('click', () => {
            if (calibrationPts.length !== 2) {
                addMessage('Please click two points first', 'error');
                return;
            }
            
            const size = parseFloat(referenceSize.value);
            if (!size || size <= 0) {
                addMessage('Please enter a valid size', 'error');
                return;
            }

            let sizeInMM = size;
            if (referenceUnit.value === 'cm') sizeInMM = size * 10;
            else if (referenceUnit.value === 'inches') sizeInMM = size * 25.4;

            const p1 = calibrationPts[0];
            const p2 = calibrationPts[1];
            const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            pixelsPerMM = distance / sizeInMM;

            calibrationStatus.className = 'status calibrated';
            calibrationStatus.textContent = '‚úÖ Calibrated successfully';
            calibrationPts = [];
            updateDisplay();
            drawImage();
            addMessage(`Calibration applied: 1 pixel = ${(1/pixelsPerMM).toFixed(4)} mm`, 'success');
        });

        // Reset
        resetBtn.addEventListener('click', () => {
            pixelsPerMM = null;
            calibrationPts = [];
            measurementPts = [];
            referenceSize.value = '';
            calibrationStatus.className = 'status uncalibrated';
            calibrationStatus.textContent = '‚ö†Ô∏è Not calibrated yet';
            results.style.display = 'none';
            updateDisplay();
            drawImage();
            addMessage('Reset complete', 'info');
        });

        function calculateMeasurement() {
            const p1 = measurementPts[0];
            const p2 = measurementPts[1];
            const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const mm = distance / pixelsPerMM;
            const inches = mm / 25.4;

            document.getElementById('resultMM').textContent = mm.toFixed(2);
            document.getElementById('resultInches').textContent = inches.toFixed(3);
            results.style.display = 'flex';
            addMessage(`Measurement: ${mm.toFixed(2)} mm (${inches.toFixed(3)} inches)`, 'success');
        }

        function drawImage() {
            if (!img) return;

            const maxWidth = 800;
            let width = img.width;
            let height = img.height;

            if (width > maxWidth) {
                const ratio = maxWidth / width;
                width = maxWidth;
                height = height * ratio;
            }

            canvas.width = width;
            canvas.height = height;

            ctx.drawImage(img, 0, 0, width, height);

            // Draw calibration points
            calibrationPts.forEach((p, i) => {
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(p.canvasX, p.canvasY, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('C' + (i + 1), p.canvasX, p.canvasY);
            });

            if (calibrationPts.length === 2) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(calibrationPts[0].canvasX, calibrationPts[0].canvasY);
                ctx.lineTo(calibrationPts[1].canvasX, calibrationPts[1].canvasY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw measurement points
            measurementPts.forEach((p, i) => {
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(p.canvasX, p.canvasY, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M' + (i + 1), p.canvasX, p.canvasY);
            });

            if (measurementPts.length === 2) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(measurementPts[0].canvasX, measurementPts[0].canvasY);
                ctx.lineTo(measurementPts[1].canvasX, measurementPts[1].canvasY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function updateDisplay() {
            document.getElementById('calibrationPointsCount').textContent = calibrationPts.length + '/2';
            document.getElementById('measurementPointsCount').textContent = measurementPts.length + '/2';
        }
    </script>
</body>
</html>
